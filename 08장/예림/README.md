# 8장. 스프링이란 무엇인가?

## 8.2 스프링의 정의

- 스프링에 대한 가장 잘 알려진 정의는 이렇다.
  - 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크

- **애플리케이션 프레임워크**
  - 보통 프레임워크나 라이브러리는 한 가지 기술 분야에 집중되지만 스프링은 애플리케이션 프레임워크라는 특징을 갖고 있다.
  - 애플리케이션 프레임워크는 특정 계층이나 기술, 업무 분야에 국한되지 않고 애플리케이션의 전영역을 포괄하는 범용적인 프레임워크
  - 개발의 전 과정을 편리하며 효율적으로 진행하는 데 일차적인 목표를 두는 프레임워크
  - 단지 여러 계층의 다양한 기술을 모아뒀기 때문에 애플리케이션 프레임워크라고 불리는 것이 아니라, **애플리케이션의 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로 해서 각 분야의 특성에 맞는 필요를 채워주고 있기 때문에 애플리케이션을 효과적으로 개발할 수 있다.**
- **경량급**
  - 스프링이 작은 규모의 코드로 이뤄졌다는 뜻은 아니다.
  - 불필요하게 무겁지 않다는 의미다. 스프링의 기원이 된 책에서 비판하는 자바 엔터프라이즈 기술의 불필요한 복잡함에 반대되는 개념
  - 고가의 느리고 무거운 자바 서버, 난해한 설정 파일 구조 등 복잡하고 무거웠던 EJB에 반해 스프링은 가장 단순한 서버환경인 톰캣(Tomcat)이나 제티(Jetty)에서도 완벽하게 동작
  - 단순한 개발툴과 기본적인 개발 환경으로도 엔터프라이즈 개발에서 필요로 하는 주요한 기능을 갖춘 애플리케이션 개발하기에 충분
  - 결과적으로 스프링은 EJB를 대표하는 기존의 많은 기술이 불필요하게 무겁고 복잡했음을 증명한 셈이고, 그런 면에서 스프링은 군더더기 없이 깔끔한 기술을 가진 '경량급' 프레임워크라고 불린 것
  - 같은 기능을 수행하는 코드인데도, 스프링 기반의 코드가 가벼운 이유는 코드에 불필요하게 등장하던, 프레임워크와 서버 환경에 의존적인 부분을 제거해주기 때문이다.
- **자바 엔터프라이즈 개발을 편하게**
  - 스프링은 근본적인 부분에서 엔터프라이즈 개발의 복잡성을 제거해내고 진정으로 개발을 편하게 해주는 해결책 제시
  - 애플리케이션 개발이란 개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않으면서도 애플리케이션의 핵심인 사용자의 요구사항, 즉 비즈니스 로직을 빠르고 효과적으로 구현하는 것을 말한다.
  - 스프링은 프레임워크가 제공하는 기술이 아니라 자신이 작성하는 애플리케이션의 로직에 더 많은 관심과 시간을 쏟게 해준다.
  - 또한 엔터프라이즈 개발의 기술적인 복잡함과 그에 따른 수고를 제거해준다.
- **오픈소스**
  - 스프링은 오픈소스 프로젝트 방식으로 개발돼왔다.
  - 아파치 라이선스에 따르면 스프링을 상업적인 목적의 제품에 포함시키거나 비공개 프로젝트에 자유롭게 이용해도 된다.
  - 그러나 공식적인 개발은 제한된 인원의 개발자에 한정된다.
  - 오픈소스는 장점도 있지만 개개인에게 극히 의존적이라는 한계도 있기 때문에 이를 아는 스프링 개발자는 프레임워크 사용자에게 지속적인 신뢰를 줄 수 있도록 전문 기업을 만들었다. 
  - 스프링은 오픈소스의 장점을 충분히 취하면서 단점과 한계도 잘 극복하고 있는 전문적인 오픈소스 소프트웨어

## 8.2 스프링의 목적
- 스프링은 더더욱 그 목표를 분명히 알고 사용하지 않으면 그 가치를 제대로 얻기 힘들다.
- 스프링은 그 기능과 API 사용 방법을 잘 안다고 해서 잘 쓸 수 있는 게 아니다.
- 그렇다면 스프링의 목적은 무엇이며, 궁극적으로 이루려고 하는 것은 무엇인가?
- 그것은 '경량급 프레임워크인 스프링을 사용해서 엔터프라이즈 개발을 편하게'하는 것이다.
- 그렇다면 굳이 스프링을 사용해서 엔터프라이즈 애플리케이션 개발을 편하게 하려는 이유는 뭘까?
- 엔터프라이즈 개발이란 편하지 않기 때문이다.

### 8.2.1 엔터프라이즈 개발의 복잡함
- 2000년대 초반 자바 엔터프라이즈 프로젝트가 많이 실패했던 가장 대표적인 이유는 '엔터프라이즈 시스템 개발이 너무 복잡해져서'였다.

#### 복잡함의 근본적인 이유
- **첫 번째는 기술적인 제약 조건과 요구사항이 늘어가기 때문이다**
  - `엔터프라이즈 시스템` : 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템
  - 엔터프라이즈 시스템은 많은 사용자의 요청을 동시에 처리해야 하기 때문에 서버의 자원을 효율적으로 공유하고 분배해서 사용할 수 있어야 한다. 또한 보안과 안정성 확장성 면에서도 뛰어나야 한다. 따라서 뛰어난 성능과 서비스의 안정성이 요구되고 그런 점을 고려한 개발 기술이 필요하다.
  - 즉, 순수한 비즈니스 로직 구현 외에도 기술적으로 고려할 사항이 많다는 것이다.
  - 엔터프라이즈 시스템이 기업 업무를 처리하는 데 핵심적인 역할로 등장하고 중요해지면서 점점 더 기술적인 요구는 심화되고 그에 따른 복잡도는 증가한다.

- **두 번째는 엔터프라이즈 애플리케이션이 구현해야 할 핵심 기능인 비즈니스 로직의 복잡함이 증가하기 때문이다**
  - 예전에는 회계처럼 복잡한 계산이나 빠른 분석이 필요한 영역에만 IT 시스템을 사용했지만 갈수록 엔터프라이즈 시스템을 이용해 핵심 업무를 처리하는 비율이 늘어감 ➡️ 엔터프라이즈 시스템에 대한 업무 의존도 증가

- 더 큰 문제는 2000년 전후로 불어 닥친 경제 위기 이후 업무 프로세스를 변경하고 조종하는 것을 상시화할 만큼 변화의 속도가 빨라졌다.
- 버그나 오류가 있어서 가아니라, 기능 요구사항과 업무 정책 등이 바뀌기 때문에 애플리케이션을 자주 수정해줘야 하는 시대가 된 것
- 그만큼 시스템 개발과 유지보수, 추가 개발 등의 작업 부담은 커지고 개발의 난이도는 더욱 증가

#### 복잡함을 가중시키는 원인
- 엔터프라이즈 애플리케이션 개발이 실패하는 주요 원인은 비즈니스 로직의 복잡함과 기술적인 복잡함
- 비즈니스 로직을 제대로 구현하는 일도 만만치 않은데 동시에 이런저런 다양한 기술적인 문제도 함께 신경써야 함
  - 예를 들어 고객에 대한 추천제품 선정을 하는 코드의 경우 XML 파서 라이브러리, 고객의 최신 정보를 얻기 위해 점검할 캐시 API, 없다면 사용할 JDBC API, 로그 라이브러리, 요청을 보낸 권한 파악과 그에 따른 예외, 트랜잭션을 위한 JTA 사용 등 신경 써야 할 다양한 기술적인 문제 존재
  - 복잡하게 얽혀 있는 코드를 헤매다 보면 정작 수정할 대상이 아닌 부분에까지 영향을 줘서 새로운 버그를 만들 수도 있음.

### 8.2.2 복잡함을 해결하려는 도전
#### 제거될 수 없는 근본적인 복잡함
- 근본적으로 엔터프라이즈 개발에 나타나는 복잡함의 원인은 제거 대상이 아니다.
- 대신 그 복잡함을 효과적으로 상대할 수 있는 전략과 기법이 필요하다.
- 문제는 비즈니스 로직의 복잡함을 효과적으로 다루기 위한 방법과 기술적인 복잡함을 효과적으로 처리하는 데 적용되는 방법이 다르다는 점이다.
- 이 두 가지 복잡함을 분리해야 한다.

#### 실패한 해결책 : EJB
- EJB가 처음에 내세웠던 목표 : 로우 레벨의 기술적인 복잡함에 신경쓰지 않고 비즈니스 로직을 효과적으로 개발하는 데 더 집중하자
- 하지만 애플리케이션 로직을 담은 핵심 코드에서 일부 기술적인 코드가 제거된 건 사실이지만, 오히려 EJB라는 환경과 스펙에 종속되는 코드로 만들어야 하는 더 큰 부담을 안게 됐다.

#### 비침투적인 방식을 통한 효과적인 해결책 : 스프링
- EJB처럼 어떤 기술을 적용했을 때 그 기술과 관련된 코드나 규약 등이 코드에 등장하는 경우를 `침투적인(invasive)` 기술이라고 한다.
- 반면에 `비침투적인(non-invasive)` 기술은 기술의 적용 사실이 코드에 직접 반영되지 않는다는 특징이 있다.
  - 어딘가에는 기술의 적용에 따라 필요한 작업을 해줌
  - 그러나 코드의 설계와 구현 방식을 제한하지 않는다
- 스프링을 통해 성격이 다른 복잡함들을 깔끔하게 분리해줬기 때문에 각각을 효과적으로 상대할 수 있는 기반이 마련됐다.

### 8.2.3 복잡함을 상대하는 스프링의 전략
- 스프링의 기본적인 전략은 비즈니스 로직을 담은 애플리케이션 코드와 엔터프라이즈 기술을 처리하는 코드를 분리시키는 것이다.

#### 기술적 복잡함을 상대하는 전략
- **첫번째 문제 : 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다**
  - 환경과 조건이 바뀌면 적용하는 기술이 달라지고 그에 따라 코드도 바뀐다는 건 심각한 문제
  - 이런 문제에 대한 스프링의 공략 방법은 `서비스 추상화`
    - 기술적인 복잡함은 일단 추상화를 통해 인터페이스를 분리하고, 세부 기술에 독립적인 접근 인터페이스를 제공하는 것이 가장 좋은 해결책이다.
    - 데이터 액세스 예외에 대한 추상화는 비즈니스 로직을 담은 서비스 레이어의 코드가 특정 기술이 발생시키는 예외에 종속되지 않고, 불필요하게 예외를 잡아야 하거나 throws를 선언해야 하는 것 방지
  - 스프링이 제공하는 템플릿/콜백 패턴은 판에 박힌 반복적인 작업 흐름과 API 사용 코드 제거 ➡️ 핵심 로직에만 집중하게 해줌
- **두 번째 문제 : 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다**
  - 기술과 비즈니스 로직의 혼재로 발생하는 복잡함을 해결하기 위한 스프링의 접근 방법은 바로 AOP
  - AOP는 최후까지 애플리케이션 로직을 담당하는 코드에 남아있는 기술 관련 코드를 깔끔하게 분리해 별도의 모듈로 관리하게 해주는 강력한 기술

#### 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략
- 비즈니스 로직은 애플리케이션에서 핵심이 되는 부분이자 자주 수정되는 부분
- 비즈니스 로직에 오류가 발생하면 엄청난 사고로 이어질 수 있음
- 예전에는 비즈니스 로직의 상당 부분을 DB에 두는 것이 유행이었으나 현재는 규모가 커지면서 이는 불편하고 위험한 일이라고 여겨지기 시작했다.
- 점차 비즈니스 로직은 애플리케이션 안에서 처리하도록 만드는 추세
  - DB는 데이터의 영구적인 저장과 복잡한 조건을 가진 검색과 같은 자체적으로 특화된 기능에 집중
  - 데이터 분석, 가공, 처리 부분은 확장하기 쉽고 비용도 싼 애플리케이션 서버로 이동
- **객체지향 프로그래밍** 기법 언어가 주는 장점을 잘 활용하면 자주 바뀌고 까다로운 비즈니스 로직을 효과적으로 구현할 수 있다.
  - 유연한 설계, 재사용성
  - 객체지향 분석과 설계(OOAD)를 통해서 작성된 모델을 코드로 구현하고 지속적인 발전 가능

#### 핵심 도구: 객체지향과 DI
- 기술과 비즈니스 로직의 복잡함을 해결하는 데 스프링이 공통적으로 사용하는 도구 : 객체지향
- 스프링의 모토는 결국 "기본으로 돌아가자" - 객체지향에 충실한 설계
- 결국 기술적인 복잡함을 효과적으로 다루게 해주는 기법은 모두 **DI**를 바탕으로 하고 있다.
  - 서비스 추상화, 템플릿 / 콜백, AOP
- 객체지향 언어를 쓴다고 객체지향 설계가 되는 것은 아님. DI는 자연스럽게 객체지향적인 설계와 개발을 이끌어주는 좋은 동반자
  - DI를 열심히 적용하다 보면 객체지향 설계의 원칙을 잘 따르고 그 장점을 살린 설계가 나올 수 있다.
- 기술적인 복잡함이 비즈니스 로직에 침범하지 못하도록 분리하는 경우도 DI가 바탕이 된 여러가지 기법이활용됨.
- 반면에 **비즈니스 로직 자체의 복잡함**을 해결하려면 DI보다는 객체지향 설계 기법이 더 중요하다.
  - 기술적인 코드에 침범당하지 않았다면 이런 설계를 비즈니스 로직을 구현하는 코드에 그대로 반영 가능
 - 스프링만 잘 공부하면 자바 언어 자체나 객체지향 설계와 개발 실력 따윈 별로 신경쓰지 않아도 엔터프라이즈 시스템 개발을 잘할 수 있을 거라고 생각하면 오산이다.
   - 스프링은 단지 거들 뿐, 객체지향을 잘 활용해서 문제를 풀어나가는 것은 개발자의 몫

## 8.3 POJO 프로그래밍
- 스프링의 essence는 엔터프라이즈 서비스 기능을 `POJO`에 제공하는 것
  - 엔터프라이즈 서비스 : 보안, 트랜잭션과 같은 엔터프라이즈 시스템에서 요구되는 기술
- 뒤집어 생각해보면 엔터프라이즈 서비스 기술과 POJO라는 애플리케이션 로직을 담은 코드를 분리했다는 뜻이기도 하다.
- '분리됐지만 반드시 필요한 엔터프라이즈 서비스 기술을 POJO 방식으로 개발된 애플리케이션 핵심 로직을 담은 코드에 제공한다'는 것이 스프링의 가장 강력한 특징과 목표

### 8.3.1 스프링의 핵심: POJO
- 스프링의 핵심 개념을 설명하는 스프링 삼각형
  <img width="402" alt="스크린샷 2024-09-05 오후 7 00 56" src="https://github.com/user-attachments/assets/513c43fb-8d50-4980-bae4-74dcc6333b3e">
- DI의 기본 아이디어 : 유연하게 확장 가능한 오브젝트를 만들어두고 그 관계는 외부에서 다이내믹하게 설정해준다
- 스프링의 주요 기술인 IoC/DI, AOP와 PSA는 애플리케이션을 POJO로 개발할 수 있게 해주는 `가능기술`이라고 불린다.

### 8.3.2 POJO란 무엇인가?
- `Plain Java Object`의 첫 글자를 따서 만든 약자
- 평범한 자바오브젝트에 붙인 멋진 이름

### 8.3.3 POJO의 조건
- **특정 규약(contract)에 종속되지 않는다**
  - 자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 한다.
    - 특정 규약을 따라 비즈니스 컴포넌트를 만들어야 하는 경우는 POJO가 아니다.
- **특정 환경에 종속되지 않는다**
  - ex) JNDI라는 서버 서비스를 필요로 하는 EJB3은 특정 환경에 종속적이므로 POJO라고 할 수 없다.
  - 순수 애플리케잉션 로직을 담고 있는 오브젝트 코드가 특정 환경에 종속되게 만드는 경우라면 그것 역시 POJO라고 할 수 없다.
  - 특히 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안 된다.
    - 직접적으로 웹이라는 환경으로 제한해버리는 오브젝트나 API에 의존해선 안된다.
    - HttpServeltRequest나 HttpSession, 캐시와 관련된 API가 등장하거나 웹 프레임워크의 클래스를 직접 이용하는 부분이 있다면 그것은 진정한 POJO라고 볼 수 없다.
- 소스코드에 메타정보를 추가해주는 애너테이션을 사용했다고 POJO가 아닌 건 아니다. 애너테이션이나 엘리먼트 값에 특정 기술과 환경에 종속적인 정보를 담고 있다면 그때는 POJO가 아니다.
- 평범한 자바 클래스를 써서 개발했다고 POJO인 것은 아니다.
  - POJO는 객체지향적인 자바 언어의 기본에 충실하게 만들어져야 한다.
- 진정한 POJO란, 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다. 그런 POJO에 애플리케이션의 핵심 로직과 기능을 담아 설계하고 개발하는 방법을 POJO 프로그래밍이라고 할 수 있다.

### 8.3.4 POJO의 장점
- **특정 기술과 환경에 종속되지 않는 오브젝트는 그만큼 깔끔한 코드가 될 수 있다.**
- **자동화된 테스트에 유리하다**
  - 환경의 제약은 코드의 자동화된 테스트를 어렵게 한다.
  - 간단한 코드 수정에도 빌드, 배치, 수동 확인이라는 번거로운 사이클에 따라 작업하기가 얼마나 힘든지는 EJB 개발자들이 경험적으로 잘 알고 있다.
- **객체지향적인 설계를 자유롭게 적용할 수 있다.**
  자바 언어의 객체지향적인 설계와 구현 방식이야말로 그 어떤 새로운 기술과 환경, 툴보다 더 실제 프로젝트를 성공시키는 데 중요한 요소

### 8.3.4 POJO 프레임워크
- `POJO 프레임워크` : POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크
  - 스프링 프레임워크, 하이버네이트가 대표적
- 다음은 스프링이 엔터프라이즈 시스템의 복잡함을 어떻게 다루는지 보여준다.
  <img width="539" alt="스크린샷 2024-09-06 오후 3 02 58" src="https://github.com/user-attachments/assets/7cacda6a-8a7c-4488-98ab-175c6b619f69">
  - 스프링은 비즈니스 로직의 복잡함과 엔터프라이즈 기술의 복잡함을 분리해서 구성할 수 있게 도와준다.
  - 하지만 자신은 기술영역에만 관여하지 비즈니스 로직을 담당하는 POJO에서는 모습을 감춘다.
  ➡️ 자신을 직접 노출하지 않으면서 애플리케이션을 POJO로 쉽게 개발할 수 있께 지원해준다.

## 8.4 스프링의 기술
- 스프링에는 POJO 프로그래밍을 손쉽게 할 수 있도록 지원하는 세 가지 가능기술을 제공한다.
  - IoC/DI, AOP, PSA
- 이 세 가지 모두 스프링이 있기 이전에도 여러가지 형태로 시도됐고 발전하고 있었다. 다만 스프링은 그것을 엔터프라이즈 개발의 전 영역에 걸쳐 효과적으로 적용될 수 있도록 프레임워크 형태로 제공하고 있다.

### 8.4.1 제어의 역전(IoC) / 의존관계 주입(DI)
- IoC/DI는 스프링의 가장 기본이 되는 기술이자 스프링의 핵심 개발 원칙이기도 하다.
- 나머지 두 가지 기술인 AOP와 PSA도 IoC/DI에 바탕을 두고 있다.
- 3대 기술은 아니지만 자주 등장하는 템플릿/콜백 패턴이 적용된 부분도 IoC/DI가 그 핵심 원리다.


#### DI 활용 방법
- **핵심 기능의 변경**
  - A → B 구조에서 A의 기능을 일부 B 에 위임한다면 B의 구현방식에 따라 B1,B2,B3으로 바꾸는것이다.
  - 이렇게 실제 의존하는 대상이 가진 핵심기능을 DI 설정을 통해 변경하는 것이 대표적인 DI 활용방법이다.
- **핵심기능의 동적인 변경**
  - 일반적인 DI를 이용한 변경방법과 달리, 동적으로 매번 다르게 변경할 수 있다.
  - 런타임 시에 동적인 방식으로 연결되지만, 한번 DI 되면 바뀌지 않는 정적인 관계를 맺어주는 것이다.
- **부가기능의 추가**
  - 핵심기능은 그대로 둔 채로 부가기능을 추가
  - 실제 사용할 오브젝트는 외부에서 주입하는 DI 주입하는 DI를 적용해두면 데코레이터 패턴을 쉽게 적용할 수 있다.
- **인터페이스의 변경**
  - 때로는 사용하려고 하는 오브젝트가 가진 인터페이스가 클라이언트 호환되지 않는 경우가 있다.
  - A가 C 오브젝트를 사용하려 한다고 해보자. 하지만 A는 원래 B 인터페이스를 사요하도록 만들어져 있고 C 는 B 인터페이스를 구현하지 않았다.
  - 이때 A가 DI를 통해 B의 구현 오브젝트를 받도록 만들어져 있다면 B 인터페이스를 구현했으면서 내부에서 C 를 호출해주는 기능을 가진 어뎁터 오브젝트를 만들어 A 에 DI 해주면 된다.
- **프록시**
  - 필요한 시점에서 실제 사용할 오브젝트를 초기화하고 리소스를 준비하게 해주는 지연된 로딩을 적용하려면 프록시가 필요
  - 원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게해주는 원격 프록시를 적용하려고 할때도 프록시가 필요
  - 두가지 방법 모두 DI를 필요로 한다.
- **템플릿과 콜백**
  - 템플릿/콜백 패턴은 DI 의 특별한 적용방법이다.
  - 반복적으로 등장하지만 항상 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 템플릿과 콜백으로 만들고 이를 DI 원리를 응용해 적용하면 코드를 간결하게 만들 수 있다.
- **싱글톤과 오브젝트 스코프**
  - DI를 프레임워크로 이용한다는건 DI 대상 오브젝트를 컨테이너가 관리한다는 의미다.
  - 오브젝트 생성부터 관계설정, 이용, 소멸에 이르기까지 모든과정을 DI 컨테이너가 주관하기 대문에 그 오브젝트의 스코프를 자유롭게 제어할 수 있다.
- **테스트**
  - 여타 오브젝트와 협력해서 동작하는 오브젝트를 효과적으로 테스트하는 방법은 가능한 한 고립시키는 것이다.

### 8.4.2 에스펙트 지향 프로그래밍
- AOP는 OOP처럼 독립적인 프로그래밍 패러다임이 아니다. (AOP와 OOP는 서로 배타적이 아니라는 말이다)
- 객체지향 기술의 한계와 단점을 극복하도록 도와주는 보조적인 프로그래밍 기술이다.
- AOP를 사용하면 그 결과로 OOP를 더욱 OOP 답게 만들 수 있다.

#### AOP의 적용 기법
AOP를 자바 언어에 적용하는 기법은 크게 두 가지로 분류할 수 있다.
- **첫 번째는 스프링과 같은 다이내믹 프록시를 사용하는 방법이다**
  - 이 방법은 기존 코드에 영향을 주지 않고 부가 기능을 적용하게 해주는 데코레이터 패턴을 응용한 것이다.
- **두 번째는 자바 언어의 자바 언어의 환계를 넘어 언어의 확장을 이용하는 방법이다**
  - AspectJ라는 유명한 오픈소스 AOP 툴이 있다.
  - AspectJ는 프록시 방식의 AOP에서는 불가능한 다양한 조인 포인트를 제공한다.
  - 메서드 호출 뿐 아니라 인스턴스 생성, 필드 액세스, 특정 호출 경로를 가진 메서드 호출 등에도 부가기능을 제공할 수 있다.

#### AOP의 적용 단계
- **AOP 적용 1단계 : 미리 준비된 AOP 이용**
  - 일단 처음에는 스프링이 미리 만들어서 제공하는 기능을 그대로 적용하는 것으로 시작한다.
  - 스프링이 미리 준비해서 제공하는 대표적인 AOP 기능
    - `트랜잭션`
    - `@Configurable` 애너테이션을 이용해서 도메인 오브젝트에 DI를 자동적용해주는 AOP 기능(AspectJ를 이용한 AOP 반드시 필요)
- **AOP 적용 2단계 : 전담팀을 통한 정책 AOP 적용**
  - 아직까지는 개발자 개개인이 AOP 기능을 직접 이용하게 해서는 안된다.
  - 대신 애플리케이션 전체적으로 이용 가능한 것을 소수의 AOP 담당자 관리 하에 적용해볼 수 있다.
- **AOP 적용 3단계 : AOP의 자유로운 이용**
  - 1,2 단계를 통해 어느 정도 친숙해지고, 장단점, 응용 전략, 위험성 등을 어느 정도 인지했다면 개발자 스스로 AOP를 활용할 수 있는 단계로 넘어갈 수 있다.


### 8.4.3 포터블 서비스 추상화(PSA)
- PSA : 환경과 세부 기술의 변화에 관계 없이 일관된 방식으로 기술에 접근할 수 있게 가능기술
- 특정 환경과 기술에 종속적이지 않다는 게 그런 기술을 사용하지 않는다는 뜻은 아니다.
  - 다만 POJO 코드가 그런 기술에 직접 노출되어 만들어지지 않는다는 말이다.
  - 이를 위해 스프링이 제공하는 기술이 서비스 추상화
- 스프링의 서비스 추상화의 개념과 장점을 잘 이해한다면 때에 따라 직접 서비스 추상화 기법을 적용할 필요도 있다
- 필요하면 스프링이 그랬던 것처럼 직접 추상 레이어를 도입하고 일관성있는 API 를 정의해서 사용하면 된다.
- 서비스 추상화를 위해 필요한 기술은 DI 뿐이다. 결국 DI 응용 방법의 한 가지이므로 DI를 적극 활용해서 개발한다면 서비스 추상화는 자연스럽게 만들어 쓸 수 있다.

## 8.5 정리
- 스프링은 그 개발 철학과 목표를 분명히 이해하고 사용해야 한다.
- POJO를 이용한 애플리케이션 개발은 시스템 개발의 복잡함이 주는 많은 문제를 해결할 수 있다.
- 스프링의 목적은 이런 POJO를 이용해 엔터프라이즈 애플리케이션을 쉽고 효과적으로 개발할 수 있도록 지원해주는 데 있다.
- POJO 방식의 개발을 돕기 위해 스프링은 IoC/DI, AOP, PSA와 같은 가능 기술을 프레임워크와 컨테이너라는 방식을 통해 제공한다.
