# 9장. 스프링 프로젝트 시작하기
## 9.1. 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션
### 9.1.1. 클라이언트와 백엔드 시스템
- 엔터프라이즈 애플리케이션은 자신이 클라이언트가 돼서 또 다른 엔터프라이즈 시스템에 서비스를 요청할 수도 있다

![alt text](image.png)

### 9.1.2. 애플리케이션 서버
- 스프링으로 만든 애플리케이션을 자바 서버 환경에 배포하려면 JavaEE (또는 J2EE) 서버가 필요하다
  - JavaEE 표준을 따르는 애플리케이션 서버 2가지
    - JavaEE의 대부분의 표준 기술을 지원, 다양한 형태의 모듈로 배포 가능한 완전한 웹 애플리케이션 서버 (WAS)
    - 웹 모듈 배포만 가능한 경량급 WAS or 서블릿/JSP 컨테이너
- 경량급 WAS/서블릿 컨테이너
  - 스프링은 톰캣이나 제티 같은 가벼운 서블릿 컨테이너로도 엔터프라이즈 애플리케이션에 필요한 핵심 기능을 모두 이용할 수 있다
- WAS
  - 고도의 안정성, 고성능 시스템에서 필수적인 안정적 리소스 관리 가능
  - 관리기능, 모니터링 기능 뛰어나 여러 대의 서버 동시 운영 시 유리하다

### 9.1.3. 스프링 애플리케이션의 배포 단위
- 독립 웹 모듈
  - 보통 war 로 패키징된 독립 웹 모듈로 배포된다
  - 톰캣 같은 서블릿 컨테이너를 사용한다면 독립 웹 모듈이 유일한 방법이다
  - 가장 편리하고 단순한 배포 단위
- 엔터프라이즈 애플리케이션
  - 확장자가 ear 인 엔터프라이즈 애플리케이션으로 패키징해서 배포 가능
- 백그라운드 서비스 모듈
  - 스프링 애플리케이션이 UI 가 불필요하며 서버 내에서 백그라운드 서비스처럼 동작할 필요가 있다면 rar 모듈로 만들어 배포 가능
- 장기적으로 서버 변경하거나 종류를 바꿀 가능성이 있다면, 서버 기능에 종속되지 않도록 주의하거나, 손쉽게 다른 서버의 기능으로 변경 가능하도록 추상화해서 사용해야 한다

## 9.2. 개발도구와 환경
### 9.2.1. JavaSE 와 JavaEE
#### JavaSE/JDK
- 스프링 3.0 은 JavaSE 5버전에서 추가된 새로운 언어,문법을 최대한 활용해서 개발되어서 기본적으로 JDK 5.0 또는 그 이상을 필요로 한다

#### JavaEE/J2EE
- 스프링 3.0 이 사용될 자바 엔터프라이즈 플랫폼으로는 J2EE 1.4 버전이나 JavaEE 5.0 이 필요하다

### 9.2.2. IDE

### 9.2.3. SpringSource Tool Suite
- 스프링 애플리케이션 개발을 위한 IDE 로 이클립스 선택한 경우, 스프링 소스 (스프링 개발 업체) 가 직접 만들어 제공하는 이클립스 확장판인 STS 사용을 고려해볼 수 있다
- STS : 최신 이클립스를 기반으로 주요 스프링 지원 플러그인, 관련 도구를 모아 스프링 개발에 최적화되도록 만들어진 IDE
  - 스프링 팀이 매번 플러그인의 호환성 문제나 버전 이슈를 검증해주기에 STS 를 사용하면 편리하다

### 9.2.4. 라이브러리 관리와 빌드 툴
#### 라이브러리 관리의 어려움
- 스프링 자체만 해도 20개 가까이 세분화된 jar 모듈이 존재하며, 직접 참조하는 필요 라이브러리는 100개가 넘는다
  - 하지만 그 모든 모듈과 라이브러리가 매번 다 쓰이는 건 아니다
- 또한 라이브러리마다 여러 개의 버전이 있고, 필요한 라이브러리 조합을 만들다보면 복잡한 의존관계 속에서 같은 라이브러리의 다른 버전이 동시에 필요한 경우도 생긴다
- **자바의 jar 는 기본적으로 압축 패키징 방법일 뿐이지 구분 가능한 독립된 모듈이 아니다**
![alt text](image-1.png)
- 위 문제를 풀 수 있는 가장 간단한 방법은 `재패키징` 이다.
  - **한쪽 버전의 클래스를 다른 패키지로 옮겨서 서로 구별되는 클래스로 만들어주는 방법이다**
  - 물론 이에 의존하는 라이브러리 코드도 변경된 패키지 내의 클래스를 사용하도록 수정 되어야 한다
- jarjar 를 이용하면 간단한 명령으로 복잡한 라이브러리 클래스를 모두 재패키징할 수 있다

#### 라이브러리 선정
- 가장 먼저 해야 할 작업은 스프링으로 만드는 애플리케이션에 정확히 어떤 기능이 필요한지를 정리하는 것이다.
- 스프링 모듈
  - 모듈 사이에 의존관계를 살펴보고 필수 의존 모듈과 선택 의존 모듈을 잘 구분해서 선정한다
- 라이브러리
  - 각 모듈이 반드시 필요로 하는 라이브러리가 무엇인지, 선택적으로 사용하는 것은 무엇인지 살펴보고 적절한 라이브러리를 선택한다

#### 빌드 툴과 라이브러리 관리
- IDE 를 사용할 수 있는 환경이 아니더라도 **일관된 빌드가 가능하도록 만드는 것이 중요하다**
- Maven 은 단순 빌드 툴을 넘어, 개발 과정에서 필요한 빌드, 테스트, 배치, 문서화, 리포팅 등의 다양한 작업을 지원하는 종합 프로젝트 관리 툴의 성격을 띠고 있다
- Maven 의 특징은 **POM 이라고 불리는 프로젝트 모델 정보를 이용한다**는 점이다
  - 프로젝트의 주요한 구조와 특징, 필요한 정보를 POM 의 프로젝트 모델 정보로 만들어두면, 이를 참조해서 Maven 에 미리 정해진 절차에 따라 빌드 또는 프로젝트 관리 작업을 진행할 수 있다
  - 절차적인 스크립트와 구조가 비슷한 ANT 와 달리 Maven 은 선언적이다
- Maven POM 이 가진 특징 중 하나는 **애플리케이션이 필요로 하는 의존 라이브러리를 선언해두기만 하면 원격 서버에서 이를 자동으로 다운 받아 사용할 수 있게 해주는 것이다**
- 더 흥미로운 기능은 `전이적 의존 라이브러리 추적 기능` 이다.
  - POM 의 의존정보에 **하나의 라이브러리를 지정하면, 지정된 라이브러리가 동작하는 데 필요한 여타 라이브러리까지 함께 다운로드 해준다.**
    - 잘 정의된 의존정보를 가진 라이브러리들을 갖고 있다면, 한두 개의 최상위 의존 라이브러리만 지정해줌으로써 그에 필요한 모든 라이브러리를 손쉽게 추가할 수 있다
- 스프링의 모든 모듈은 POM 정보를 갖고 있고, 이 정보를 참고하면 모듈을 사용하는 데 필요한 라이브러리와 버전을 알 수 있다
  - 하지만 필수 라이브러리는 몇개 되지 않고, 선택 라이브러리는 Maven 의 전이적 의존 라이브러리 추적 기능의 적용을 받지 못한다.
  - 따라서 POM 정보를 참고할 수 있지만 사용하려면 명시적으로 POM 에 선언해줘야 한다
  - 결국, Maven 을 사용하고 POM 정보를 이용해도 실제 적용할 라이브러리를 선정하는 수고가 사라지진 않는다
- 어차피 개발자가 스스로 필요한 라이브러리를 선택해야 한다면 굳이 Maven 같은 라이브러리 관리 기능 툴이 필요할까? 
  - YES. 라이브러리의 효과적인 관리 측면에서 필요 !
- 조직 차원에서 프로젝트에서 변하지 않고 공통적으로 사용하는 기술 목록을 만들고, 그 기술을 적용할 때 필요한 모든 스프링 모듈과 라이브러리 선정한다.
  - 해당 목록을 갖고, 라이브러리 목록만 담긴 간단한 POM 파일을 만들고 사내 로컬 Maven 레포지토리를 셋업하고 POM 파일을 업로드한다
  - 개별 프로젝트에서는 이 공통 POM 자체를 의존 정보를 넣어 사용한다
- **기업이나 개발팀 내에서 사용하는 의존 라이브러리 그룹을 만들고, 이를 POM 과 같은 빌드 툴이 활용할 정보로 생성**해두면 매우 편리하게 이를 조합해서 모듈과 라이브러리를 지정할 수 있다

#### 스프링 모듈의 두 가지 이름과 리포지토리
> spring-core-3.0.7.RELEASE.jar <br> // Maven 에서 사용하는 명명 규칙 (artifactId + version)
> org.springframework.core-3.0.7.RELEASE.jar // OSGi 의 모듈 명명 규칙 
- 두 파일은 동일하지만, 배포되는 기술에 따라 관례적으로 다른 이름을 사용한다

## 9.3. 애플리케이션 아키텍처
- 아키텍처 : 어떤 경계 안의 내부 구성요소들이 어떤 책임을 가지고, 어떤 방식으로 서로 관계를 맺으며 동작하는지를 규정하는 것

### 9.3.1. 계층형 아키텍처

#### 아키텍처와 SoC
- 지금까지 해온 DI 를 바탕으로 한 유연한 설계와 구현 전략
  - 성격이 다른 코드가 얽혀 있는 것을 2개의 오브젝트로 분리
  - 그 사이에 유연한 결합을 갖도록 인터페이스를 두고
  - 그 관계를 맺어주는 제 3의 존재인 DI 컨테이너를 두고 오브젝트끼리는 직접적 관계를 알지 못하도록 하는 것
- **성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋다**
- `계층형 아키텍처` (멀티 티어 아키텍처) : 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것
  - 보통 웹 기반 엔터프라이즈 애플리케이션은 일반적으로 3개의 계층을 갖는다고 해서 `3계층 애플리케이션`이라고도 한다

#### 3계층 아키텍처와 수직 계층
![alt text](image-2.png)

- **데이터 액세스 계층**
  - DAO 계층 (DAO 패턴을 보편적으로 사용하므로)
  - 대개는 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임이다
  - 사용 기술에 따라 다시 세분화된 계층으로 구분된다. (추상화 수준에 따른 구분)
![alt text](image-3.png)
- JdbcTemplate 을 사용하는 데이터 액세스 계층의 특징 : JdbcTemplate 이 `추상화`를 위한 계층으로 사용돼서 로우레벨 기반 계층에 존재하는 JDBC, 드라이버, 스프링 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다
- **서비스 계층**
  - 잘 만들어진 스프링 애플리케이션의 **서비스 계층 클래스는 이상적인 POJO 로 작성된다**
  - POJO 로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있다
  - 이 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다.
    - 기술 API 를 직접 다루는 코드가 아니기에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화가 필요 없다
![alt text](image-4.png)
  - 일반적으로 서비스 계층이 필요에 따라 기반 서비스 계층 API 를 호출해서 이용한다
  - 하지만 서비스 계층의 코드를 기반 서비스 계층에서 실행시키는 경우가 있다
    - ex. 스케줄링 (미리 정해진 시간에 특정 서비스 계층 로직이 동작하도록 기반 서비스 계층에서 호출)
  - 원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되어선 안된다
    - **서비스 계층 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어 특정 구현과 기술에 대한 종속성을 제거해야 한다**
  - 이상적인 서비스 계층은 데이터 액세스 계층, 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다
- **프레젠테이션 계층**
  - 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 **클라이언트 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다**

#### 계층형 아키텍처 설계의 원칙
- 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스레 낮아진다
```java
public ResultSet findByUser(String name) throws SQLException;
```
- 위 코드와 같이 데이터 액세스 계층 기술과 그 역할을 다른 계층에 노출하면 특정 데이터 액세스 계층의 구현에 종속되는 강한 결합이 만들어진다
  - ResultSet : JDBC 의 오브젝트
  - SQLException : JDBC 기술 종속적 예외 (체크예외)
```java
public List<User> findByUser(String name) throws DataAccessException;
```
  - User : 특정 계층에 종속되지 않는 단순한 오브젝트
  - DataAccessException : 특정 구현 방식에 종속되지 않는 런타임 예외
<br>
- 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하면 안된다. ex) HttpServletRequest, HttpSession
  - **계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않은 오브젝트 형태로 변환해줘야 한다**
- 서비스 계층에 웹 관련 오브젝트가 존재하면 POJO 기반의 빠르고 간단한 단위테스트 작성이 어렵다
- 계층 사이 호출은 인터페이스를 통해 이뤄져야 한다.
  - **인터페이스를 사용하겠다는 건 각 계층의 경계를 넘어서 들어오는 요청을 명확히 정의하겠다는 의미다**

### 9.3.2. 애플리케이션 정보 아키텍처
- 비교적 장기적으로 보관되는 상태정보는 주로 DB 에 저장된다
- 하나의 업무작업이 여러 번의 요청과 페이지에 걸쳐 일어나는 경우 유지되어야 하는 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고, 서버의 사용자별 세션 메모리에 저장되기도 한다
- 엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 `데이터` 로 다루는 경우, `오브젝트` 로 다루는 경우 2가지 기준으로 구분할 수 있다
- 데이터 중심 아키텍처 : 애플리케이션에 흘러다니는 정보를 단순히 값이나, 값을 담기 위한 오브젝트 형태로 취급하는 구조
  - DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고, 값을 취급하는 코드를 만들어 로직 구현하고, 값을 그대로 프레젠테이션 계층의 뷰와 연결해주는 것
- 데이터 중심 설계 특징은 **비즈니스 로직이 DB 내부의 저장 프로시저나 SQL 에 담겨 있는 경우가 많다**
  - 보통 DB에서 돌려주는 내용을 그대로 맵이나 단순 결과 저장용 오브젝트에 넣어서 전달한다

#### DB/SQL 중심의 로직 구현 방식
- 데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다
- 대용량 데이터를 다루면서 빠른 처리가 필요할 경우, 일부 로직을 **DB 내에 존재하는 PL/SQL 과 같은 저장 프로시저 형태로 만들기도 한다**
- DB 중심의 업무 단위로 코드를 만들면 애플리케이션 내에 흘러다니는 정보는 항상 단순한 포맷의 데이터다.
  - 이러한 방식은 변화에 매우 취약하며, 객체지향의 장점이 활용되지 못하는 데다 각 계층의 코드가 긴밀하게 연결되어 있어 중복 제거도 쉽지 않다
  - 로직을 DB와 SQL에 많이 담을수룩 확장성이 떨어진다
- 상대적으로 애플리케이션 서버와 그 안의 오브젝트는 비용이 적게 들고, 안정성도 높아지며, 코드 검증도 편리하다

#### 거대한 서비스 계층 방식
- DB에는 부하가 걸리지 않게 저장 프로시저 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층 코드에서 처리하도록 만드는 것이다
- 이 방식에서 DAO는 좀 더 단순한 결과를 돌려주고, **DAO가 돌려준 정보를 분석, 가공하며 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 된다**
  - DAO와 SQL은 상대적으로 단순해지고, 그 중 일부는 여러 서비스 계층 코드에서 재사용이 가능해진다
- 거대 서비스 계층 방식 장점
  - 애플리케이션 코드에 비즈니스 로직이 담겨있어 자바언어의 장점을 활용하여 로직을 구현할 수 있고 테스트하기 수월하다
  - 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다
- 거대 서비스 계층 방식 단점
  - 필요한 데이터가 일관성 없이 매번 달라지므로 서비스 계층 코드나 DAO에 적지 않은 중복이 발생한다
- 데이터 중심 아키텍처의 특징은 **계층 사이의 결합도가 높은 편이고 응집도는 떨어진다.**
- 화면을 중심으로 하는 `업무 트랜잭션 단위`로 코드가 모이므로 처음엔 개발하기 편하지만, 중복이 많아지기 쉽고 장기적으로 유지보수하기 힘들다