# 9장. 스프링 프로젝트 시작하기

## 9.1 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션
- 스프링은 **자바 언어를 사용하는 모든 종류의 프로젝트**라면 어디든 사용할 수 있다.
- 그러나 스프링은 주로 자바 엔터프라이즈 환경에서 동작하는 애플리케이션을 개발하는 목적으로 사용된다.
  -  자바 엔터프라이즈 애플리케이션은 서버에서 동작
-  그러나 클라이언트의 요청 없이도 정해진 시간이나 특정 이벤트 발생에 따라 독자적으로 작업을 수행하기도 한다.

### 9.1.1 클라이언트와 백엔드 시스템
- 엔터프라이즈 애플리케이션은 자신이 클라이언트가 돼서 또 다른 엔터프라이즈 시스템에 서비스를 요청할 수도 있다.
- 가장 많이 사용되는 구조는 'DB를 웹 애플리케이션' 구성
  - 클라이언트가 웹 브라우저, 백엔드 시스템이 DB
- 이외에도 자바 버서가 받아들일 수 있는 방식으로 요청을 보내기만 한다면 어떤 종류의 클라이언트든 상관 없다.
<img width="669" alt="스크린샷 2024-09-09 오후 2 12 30" src="https://github.com/user-attachments/assets/dc7ad25e-379a-4467-8d27-ddff31b7d841">

### 9.1.2 애플리케이션 서버
- 스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE 서버가 필요하다.
- JavaEE 표준을 따르는 애플리케이션 서버는 크게 두 가지로 구분할 수 있다.
  - WAS
  - 경량급 WAS 또는 서블릿/JSP 컨테이너
- **경량급 WAS/서블릿 컨테이너**
  - 스프링은 기본적으로 톰캣이나 제티 같은 가벼운 서블릿 컨테이너만 있어도 충분
  - 기존에 EJB와 WAS를 사용해야 가능했던 선언적인 트랜잭션이나 선언적 보안, DB 연결 풀링, 리모팅이나 웹 서비스는 물론이고 추가적인 라이브러리의 도움을 받으면 분산 / 글로벌 트랜잭션까지 가능
- **WAS**
  - 고가의 WAS를 사용하면 그만큼 장점이 있음
    - 고도의 안정성이나 고성능 시스템에서 필수적인 안정적인 리소스 관리, 레거시 시스템의 연동이나 기존 EJB로 개발된 모듈을 함께 사용하는 등의 필요가 있다면 사용할 수 있음
  - 상대적으로 관리 기능이나 모니터링 기능이 뛰어나서 여러 대의 서버를 동시에 운영할 때 유리한 점이 많음
  - 무엇보다 자바 엔터프라이즈 버전(JavaEE) 표준을 최대한 활용 가능

- 스프링 개발 팀은 비용을 들이더라도 적합한 조건을 가진 WAS 사용 권장
- 스프링은 JavaEE와 배타적이지 않음. 스프링은 JavaEE 표준 기술을 적극 지원하고 있다.
- 물론 WAS 사용 시 분명한 이유와 근거가 있는지 검토 필요

#### 스프링소스 tcServer
- 실제로 개발환경과 운영환경에서 가장 많이 사용되는 자바 서버는 웹 모듈만 지원하는 서블릿 컨테이너인 아파치 톰캣
- 스프링 개발을 책임지는 기업인 스프링소스에는 톰캣 핵심 개발자들이 포진해 있다. 이들이 중심이 돼서 엔터프라이즈 스프링 애플리케이션에 최적화된 경량급 애플리케이션 서버인 tcServer를 개발했다.
- 기존 톰캣에서는 아쉬웠던 고급 서버 관리 기능, 배포 기능과 진단 기능을 포함해서 톰캣 전문가에게 받는 기술 지원도 함께 제공받을 수 있다.
- 가장 큰 장점은 스프링 애플리케이션 개발과 운영에 꼭 필요한 중요한 기능이 많이 제공된다는 점이다.


### 9.1.3 스프링 애플리케이션의 배포 단위
- 스프링으로 만든 애플리케이션은 다음의 세 가지 단위로 배포할 수 있다.
  - **독립 웹 모듈**
    - 스프링은 보통 war로 패키징된 웹 모듈로 배포됨
    - 톰캣 같은 서블릿 컨테이너를 쓴다면 독립 웹 모듈이 유일한 방법
  - **엔터프라이즈 애플리케이션**
    - 경우에 따라선 확장자가 ear인 엔터프라이즈 애플리케이션으로 패키징해서 배포할 수도 있다.
    - 스프링 애플리케이션에서 EJB 모듈을 긴밀하게 사용하거나 반대로 EJB 모듈에서 스프링으로 만든 애플리케이션을 이용해야 한다면, EJB와 스프링 웹 모듈을 엔터프라이즈 애플리케이션으로 통합해야 한다.
    - 또는 하나 이상의 웹 모듈과 별도로 분리된 공유 가능한 스프링 컨텍스트를 엔터프라이즈 애플리케이션으로 묶을 수 있다.
  - **백그라운드 서비스 모듈**
    - J2EE 1.4에서 등장한 rar 패키징 방법
    - rar : 리소스 커넥터를 만들어 배포할 때 사용하는 방식
    - 스프링 애플리케이션이 UI를 가질 필요는 없고 서버 내에서 백그라운드 서비스처럼 동작할 필요가 있다면 사용

## 9.2 개발 도구와 환경
### 9.2.1 JavaSE JavaEE

#### JavaSE/JDK
- 스프링 3.0은 `JavaSE 5` 버전에서 추가된 특징을 최대한 활용 ➡️ `JDK 5.0` 또는 그 이상 필요
  - 일부는 JDK 6.0의 API를 이용해 개발
- 그 이전 환경을 고집할 필요는 없음

#### JavaEE/J2EE
- 스프링 3.0이 사용될 자바 엔터프라이즈 플랫폼으로는 `J2EE 1.4` 버전이나 `JavaEE 5.0` 필요
- `J2EE 1.4` 버전 서버 사용 시 JDK 5.0에서 동작하는지 반드시 확인
  
### 9.2.2 IDE
- 스프링은 자바5 이상 언어 지원 개발도구와 스키마를 지원하는 XML 편집기 정도만 있다면 불편 없이 개발 가능
- IntelliJ IDEA 대표적

### 9.2.3 SpringSource Tool Suite
- IDE로 이클립스 선택 시 스프링소스가 직접 만들어 제공하는 이클립스 확장판인 STS 사용 고려해보자.
- STS에는 이클립스의 기본 설치 버전에는 없는 스프링 개발지원 플러그인 기본적으로 포함

#### SpringIDE 플러그인
- 스프링 개발에 유용한 기능 제공하는 플러그인
- 다음과 같이 XML 설정 파일을 읽어서 자동으로 빈 의존관계 그래프도 그려준다.
  <img width="431" alt="image" src="https://github.com/user-attachments/assets/0c43b1b7-3399-4370-b1b0-064555095429">

#### STS 플러그인
- 스프링 개발과 설정 파일 편집을 지원하는 SpringIDE에 더해서 스프링 애플리케이션의 서버 배치와 같은 추가 기능 제공

#### 기타 플러그인
- M2Eclips, AJDT, VMCI, WTP, EMP, Mylyn, DSDP 등

### 9.2.4 라이브러리 관리와 빌드 툴
- 애플리케이션 프로젝트를 IDE에 구성할 차례다.

#### 라이브러리 관리의 어려움
> 스프링으로 애플리케이션을 만들 때 어떤 라이브러리들이 필요할까?
- 문제
  - 많은 모듈과 라이브러리가 있지만 모든 것이 매번 쓰이는 것은 아니다.
  - 라이브러리마다 여러 개의 버전이 있다는 것도 문제다.
  - 필요한 라이브러리 조합을 만들다 보면 복잡한 의존 관계 속에서 같은 라이브러리의 다른 버전이 동시에 필요해서 문제가 발생
  - 자바는 모듈이라는 개념이 없고, 독립 모듈로 패키징이 가능한 jar 파일이 있다.
    - 자바의 jar는 기본적으로 압축 패키징 방법일 뿐이지 구분 가능한 독립된 모듈이 아니다.
  - 다음과 같은 라이브러리의 두 가지 버전이 존재하는 애플리케이션 의존관계에서, `C 1.0`과 `C 2.0`에 **이름이 같지만 구현이 다른 클래스**가 있다면 이에 의존하고 있는 A나 B 하나는 비정상적으로 동작할 것이다.
    <img width="611" alt="스크린샷 2024-09-12 오후 8 06 50" src="https://github.com/user-attachments/assets/17262892-ca52-48bb-a38d-5dbfd0e6d0d5">

- 이 문제를 풀 수 있는 가장 간단한 방법은 **재패키징**이다.
  - 한쪽 버전의 클래스를 다른 패키지로 옮겨서 서로 구별되는 클래스로 만들어준다.
  - org.library.libCalss라는 이름의 클래스를 가졌다고 할 때, 두 개의 클래스가 이름은 같지만 호환이 안 된다면 그중 한 버전을 org.library.repack.LibClass와 같은 식으로 패키지를 바꿔주고 이 버전을 사용하는 라이브러리도 org.library.repack 패키지 밑에 있는 클래스를 쓰도록 만들어야 한다.
- 이런 재패키징은 쉽지 않다.
- 툴도 존재 : jarjar

#### 라이브러리 선정
- 라이브러리를 선정하고 추가, 제거하는 등의 관리는 여러모로 신경써야할 게 많다.
- 가장 먼저 해야 할 작업은 스프링으로 만드는 애플리케이션에서 정확히 어떤 기능이 필요할지 정리하는 것

- **스프링 모듈**
  - 스프링의 모듈 사이에도 의존 관계가 있다.
  - 부록 A에 나와 있는 모듈의 의존 관계와 주요 기능을 잘 살펴보고 필수 의존 모듈과 선택 의존 모듈을 잘 구분해서 선정하자.
- **라이브러리**
  - 스프링의 각 모듈은 또 다른 모듈에 의존하기도 하지만 오픈소스 라이브러리 또는 표준 API를 필요로 하기도 하고 경우에 따라서 상용 제품의 라이브러리에 의존
  - 부록 B에 나온 스프링 모듈과 그에 의존하는 라이브러리 종류와 특징을 살펴보고 그중에서 적절한 라이브러리를 선택한다.
- 부록 A와 B에 나와있는 모듈과 라이브러리의 의존관계와 설명을 읽고 적용하면 기본적으로 필요한 라이브러리 선정 가능
  - 애매한 경우에는 시행착오 방법을 어쩔 수 없이 써야 함
- 먼저 스프링 관련 라이브러리 jar 파일을 모두 가져다 하나의 폴더에 넣고 압축을 푼 다음, 확실히 필요하다고 생각하는 라이브러리와 모듈만 갖고 일단 개발을 하다가 클래스를 찾을 수 없다고 예외를 만나게 되는 경우 압축을 해제한 폴더에서 검색을 해본 뒤 해당 파일을 추가해준다.
- 물론 라이브러리 관리는 어떤 방법을 써도 간단하지 않지만 꼼꼼하게 필요한 것들을 찾아 사용하는 것이 최선이다.

#### 빌드 툴과 라이브러리 관리
- Maven과 ANT는 자바의 대표적인 빌드 툴
- Maven은 단순 빌드를 넘어서 개발 과정에서 필요한 빌드, 테스트, 배치, 문서화, 리포팅 등의 다양한 작업을 지원하는 종합 프로젝트 관리 툴의 성격을 띠고 있음.
- POM이라고 불리는 프로젝트 모델 정보를 이용한다는 점도 특징
- 절차적인 스크립트 구조가 비슷한 ANT와 달리 Maven은 선언적
- Maven POM은 애플리케이션이 필요하는 의존 라이브러리를 선언만 하면 원격 서버에서 자동 다운로드
  - **전이적 의존 라이브러리 추적 기능** : POM의 의존 정보에 하나의 라이브러리를 지정하면 지정된 라이브러리가 동작하는 데 필요한 여타 라이브러리까지 함께 다운
- 프로젝트 안에 POM을 통해서 의존 라이브러리 정보만 갖게 하고 필요한 라이브러리는 Maven 빌드 과정 중에 자동으로 다운로드 받거나 로컬 공통 리포지토리에서 가져오게 하면 프로젝트의 파일 크기도 줄어들고 코드 관리도 단순해짐.
> 그렇다고 실제 적용할 라이브러리를 선정하는 수고가 사라지는 것은 아니다. 그러나 편해진다.

- 기업이나 개발 팀 내에서 사용하는 의존 라이브러리의 그룹을 만들고 이를 POM과 같은 빌드 툴이 활용할 정보로 생성해주면 그 다음부터는 매우 편리하게 이를 조합해서 모듈과 라이브러리를 지정할 수 있다.
> 다음은 common, springmvc, hibernate라는 미리 준비된 의존 라이브러리 그룹을 지정해서 애플리케이션 설정을 만드는 예다.
    <img width="609" alt="스크린샷 2024-09-14 오후 9 21 55" src="https://github.com/user-attachments/assets/03d4cb17-3249-48a8-a67f-ee39e3d97544">

- Maven을 사용했다면 다음과 같이 의존 정보를 정의해주면 된다.
  <img width="538" alt="스크린샷 2024-09-15 오후 4 25 28" src="https://github.com/user-attachments/
  assets/b8b4ef54-b57d-41e3-85cf-20594f83dd7c">
  <img width="531" alt="스크린샷 2024-09-15 오후 4 25 35" src="https://github.com/user-attachments/assets/18103409-2d01-473f-9554-92374f7f6cca">

#### 스프링 모듈의 두 가지 이름과 리포지토리
- 인터넷 검색을 통해 발견할 수 있는 스프링 모듈 jar 파일의 이름을 살펴보면 두 가지 종류가 있다.
  - ex) core 모듈이라면 다음과 같이 두 가지 이름의 파일 존재
  <img width="518" alt="스크린샷 2024-09-15 오후 4 26 53" src="https://github.com/user-attachments/assets/99890234-79d2-4c2c-8dd1-aef133027240">
- 이 두 파일은 동일한 파일이다. 단지 배포되는 기술에 따라서 **관례적으로 다른 이름 사용**할 뿐
- **첫 번째 파일명 : Maven 명명 규칙을 사용**
  - Maven은 그룹 아이디와 아티팩트 아이디, 그리고 버전 세 가지로 라이브러리를 정의하는데 그중에서 아티팩트 아이디와 버전을 조합해서 **파일 이름**으로 사용
  - POM에는 다음과 같은 형식으로 의존 라이브러리 지정
    ```xml
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-core</artifactId>
      <version>3.0.7.RELEASE</version>
    </dependency>
    ```
- **두 번째 파일명 : OSGi의 모듈 명명 규칙을 사용**
  - 스프링의 모든 모듈은 OSGi 호환 모듈로 만들어져 있다.
  - OSGi 플랫폼에서 사용되지 않아도 OSGi 스타일의 모듈 이름 사용 권장
  - OSGi 호환 이름을 갖는 스프링 모듈을 사용할 경우 Maven 표준 리포지토리 대신 스프링소스가 제공하는 엔터프라이즈 번들 리포지토리를 사용해야 한다.
  - 이 때는 다음과 같은 형식으로 스프링소스 리포지토리 위치 지정
    <img width="558" alt="스크린샷 2024-09-15 오후 4 32 41" src="https://github.com/user-attachments/assets/505406a7-076d-4ac1-95a4-cf18047c1232">

  - 리포지토리를 지정했다면 스프링의 표준 모듈 이름을 따라서 다음과 같이 의존 라이브러리 선언 가능
    <img width="534" alt="스크린샷 2024-09-15 오후 4 33 04" src="https://github.com/user-attachments/assets/a7778a80-de37-4d11-97a2-9537dc7a83f9">

## 9.3 애플리케이션 아키텍처
- 아키텍처 : 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것
  - 동적인 행위와 깊은 관계가 있다.
 
### 9.3.1 계층형 아키텍처

#### 아키텍처와 SoC
- 성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋다.
- 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 **계층형 아키텍처**라고 부른다.
  - 또는 계층이라는 의미를 가진 단어 tier를 써서 멀티 티어 아키텍처라고도 한다.
- 보통 웹 기반 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 **3계층 애플리케이션**이라고도 한다.

#### 3계층 아키텍처와 수직 계층
백엔드나 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 `데이터 액세스` 계층, 비즈니스 로직을 담고 있는 `서비스` 계층, 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 `프레젠테이션` 계층으로 구분한다.
<img width="623" alt="스크린샷 2024-09-16 오후 9 55 14" src="https://github.com/user-attachments/assets/fd4f95fe-802c-4ba9-bdc2-f821bd42d05f">

- **데이터 액세스 계층**
  - DAO 패턴을 보편적으로 사용하기 때문에 DAO 계층이라고도 불림
  - 대개는 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임
  > 외부 시스템을 호출해서 서비스를 이용하는 것은 기반(infrastructure) 계층으로 분류하기도 함.
  - 데이터 액세스 계층은 사용 기술에 따라 세분화 가능(추상화 레벨에 따라 분리)
    <img width="599" alt="스크린샷 2024-09-16 오후 9 57 30" src="https://github.com/user-attachments/assets/1e94d499-7828-469c-b43b-2baa5e47a9f3">
  - 세분화된 계층은 추상화 수준에 따른 구분이기 때문에 수직적인 계층이라고도 함
  - 새로운 추상화된 계층을 추가하면 코드에 지대한 영향을 끼치기 때문에 신중해야 함
- **서비스 계층**
  - 서비스 계층은 이상적인 POJO로 작성됨
  - POJO로 만든다면 비즈니스 로직의 핵심을 잘 담아내고, 이를 유연하게 확장할 수 있음
  - 서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없음
    - 기술 API를 직접 다루지 않기 때문에 추상화가 필요 없기 때문임
  - 비즈니스 로직을 담은 서비스 계층과 엔터프라이즈 서비스를 제공하는 기반 서비스 계층을 잘 구분해야 함
  - 
